"""The main Space in the :mod:`~basiclife.BasicTerm_S` model.

:mod:`~basiclife.BasicTerm_S.Projection` is the only Space defined
in the :mod:`~basiclife.BasicTerm_S` model, and it contains
all the logic and data used in the model.

.. rubric:: Parameters and References

(In all the sample code below,
the global variable ``Projection`` refers to the
:mod:`~basiclife.BasicTerm_S.Projection` Space.)

Attributes:

    point_id: The ID of the selected model point.
        ``point_id`` is defined as a Reference, and its value
        is used for determining the selected model point.
        By default, ``1`` is assigned. To select another model point,
        assign its model point ID to it::

            >>> Projection.point_id = 2

        ``point_id`` is also defined as the parameter of the
        :mod:`~basiclife.BasicTerm_S.Projection` Space,
        which makes it possible to create dynamic child space
        for multiple model points::

            >>> Projection.parameters
            ('point_id',)

            >>> Projection[1]
            <ItemSpace BasicTerm_S.Projection[1]>

            >>> Projection[2]
            <ItemSpace BasicTerm_S.Projection[2]>

        .. seealso::

           * :attr:`model_point_table`
           * :func:`model_point`

    model_point_table: All model point data as a DataFrame.
        The sample model point data was generated by
        *generate_model_points.ipynb* included in the library.
        The DataFrame has an index named ``point_id``,
        and :func:`model_point` returns a record as a Series
        whose index value matches :attr:`point_id`.
        The DataFrame has columns labeled ``age_at_entry``,
        ``sex``, ``policy_term``, ``policy_count``
        and ``sum_assured``.
        Cells defined in :mod:`~basiclife.BasicTerm_S.Projection`
        with the same names as these columns return
        the corresponding column's values for the selected model point.
        (``policy_count`` is not used by default.)

        .. code-block::

            >>> Projection.model_poit_table
                       age_at_entry sex  policy_term  policy_count  sum_assured
            point_id
            1                    47   M           10             1       622000
            2                    29   M           20             1       752000
            3                    51   F           10             1       799000
            4                    32   F           20             1       422000
            5                    28   M           15             1       605000
                            ...  ..          ...           ...          ...
            9996                 47   M           20             1       827000
            9997                 30   M           15             1       826000
            9998                 45   F           20             1       783000
            9999                 39   M           20             1       302000
            10000                22   F           15             1       576000

            [10000 rows x 5 columns]

        The DataFrame is saved in the Excel file *model_point_table.xlsx*
        placed in the model folder.
        :attr:`model_point_table` is created by
        Projection's `new_pandas`_ method,
        so that the DataFrame is saved in the separate file.
        The DataFrame has the injected attribute
        of ``_mx_dataclident``::

            >>> Projection.model_point_table._mx_dataclient
            <PandasData path='model_point_table.xlsx' filetype='excel'>

        .. seealso::

           * :attr:`point_id`
           * :func:`model_point`
           * :func:`age_at_entry`
           * :func:`sex`
           * :func:`policy_term`
           * :func:`sum_assured`


    disc_rate_ann: Annual discount rates by duration as a pandas Series.

        .. code-block::

            >>> Projection.disc_rate_ann
            year
            0      0.00000
            1      0.00555
            2      0.00684
            3      0.00788
            4      0.00866

            146    0.03025
            147    0.03033
            148    0.03041
            149    0.03049
            150    0.03056
            Name: disc_rate_ann, Length: 151, dtype: float64

        The Series is saved in the Excel file *disc_rate_ann.xlsx*
        placed in the model folder.
        :attr:`disc_rate_ann` is created by
        Projection's `new_pandas`_ method,
        so that the Series is saved in the separate file.
        The Series has the injected attribute
        of ``_mx_dataclident``::

            >>> Projection.disc_rate_ann._mx_dataclient
            <PandasData path='disc_rate_ann.xlsx' filetype='excel'>

        .. seealso::

           * :func:`disc_rate_mth`
           * :func:`disc_factors`

    mort_table: Mortality table by age and duration as a DataFrame.
        See *basic_term_sample.xlsx* included in this library
        for how the sample mortality rates are created.

        .. code-block::

            >>> Projection.mort_table
                        0         1         2         3         4         5
            Age
            18   0.000231  0.000254  0.000280  0.000308  0.000338  0.000372
            19   0.000235  0.000259  0.000285  0.000313  0.000345  0.000379
            20   0.000240  0.000264  0.000290  0.000319  0.000351  0.000386
            21   0.000245  0.000269  0.000296  0.000326  0.000359  0.000394
            22   0.000250  0.000275  0.000303  0.000333  0.000367  0.000403
            ..        ...       ...       ...       ...       ...       ...
            116  1.000000  1.000000  1.000000  1.000000  1.000000  1.000000
            117  1.000000  1.000000  1.000000  1.000000  1.000000  1.000000
            118  1.000000  1.000000  1.000000  1.000000  1.000000  1.000000
            119  1.000000  1.000000  1.000000  1.000000  1.000000  1.000000
            120  1.000000  1.000000  1.000000  1.000000  1.000000  1.000000

            [103 rows x 6 columns]

        The DataFrame is saved in the Excel file *mort_table.xlsx*
        placed in the model folder.
        :attr:`mort_table` is created by
        Projection's `new_pandas`_ method,
        so that the DataFrame is saved in the separate file.
        The DataFrame has the injected attribute
        of ``_mx_dataclident``::

            >>> Projection.mort_table._mx_dataclient
            <PandasData path='mort_table.xlsx' filetype='excel'>

        .. seealso::

           * :func:`mort_rate`
           * :func:`mort_rate_mth`

    np: The `numpy`_ module.
    pd: The `pandas`_ module.

.. _numpy:
   https://numpy.org/

.. _pandas:
   https://pandas.pydata.org/

.. _new_pandas:
   https://docs.modelx.io/en/latest/reference/space/generated/modelx.core.space.UserSpace.new_pandas.html

"""

from modelx.serialize.jsonvalues import *

_formula = lambda point_id: None

_bases = []

_allow_none = None

_spaces = []

# ---------------------------------------------------------------------------
# Cells

def AGE(t):
    """The attained age at time t."""
    if t < 0:
        raise ValueError("t cannot be less than 0")
    else:
        n = Input.mort_table.index.max()
        return Input.np.minimum(AGE_AT_ENTRY() + DUR_Y(t), n)


def AGE_AT_ENTRY():
    """The age at entry of the selected model point"""

    return MP()["age_at_entry"]


def DTH_BEN(t):
    """Death claims"""

    return (DUR_M(t) <= POL_TERM_M()) * SUM_ASSURED() * POLS_DTH(t)


def COMM(t): 
    """Commissions"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        n = Input.comm_rates.index.max()
        dur_m = list(Input.np.minimum(Input.np.ceil(DUR_M(t)/12), n))
        comm_rates = Input.comm_rates["Projection"][dur_m]

        return (DUR_M(t) < POL_TERM_M()) * PREM_PAYBL_M(t) * list(comm_rates)


def DUR_Y(t):
    """Duration in force in years"""

    return DUR_M(t)//12


def EXPS_ACQ(t):
    """Acquisition expense per policy"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        i        = Input.exp_acq["Fixed"]
        per_prem = Input.exp_acq["% of Premium"]
        per_sa   = Input.exp_acq["% of SA"]

        exp_acq = i + per_prem * PREM_PP() + per_sa * SUM_ASSURED()
        return exp_acq * (DUR_M(t-1) == 0)


def EXPS_MAINT(t):
    """Annual maintenance expense per policy

    Note: "% of Reserve" maintenance expense has been
    omitted for now to avoid recursive calculations"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        e           = Input.exp_maint["Fixed"]/12 * INFL_FAC(t-1)
        per_prem    = Input.exp_maint["% of Premium"]
        per_res     = 1 - (1 - Input.exp_maint["% of Reserve"]) ** (1/12)
        flag        = (DUR_M(t-1) > 0) * (DUR_M(t) <= POL_TERM_M())

        return flag * (e
                       + per_prem * PREM_PP()/12
                       + per_res * RESERVE_PP(t))* POLS_IF(t-1)


def EXPS(t):
    """Total expenses accounting for acquisition,
        maintenance and claim expenses"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        acq   = EXPS_ACQ(t)
        maint = EXPS_MAINT(t) 
        claim = EXPS_CLAIM(t) 
        return (DUR_M(t) <= POL_TERM_M()) * (acq + maint + claim)


def INFL_FAC(t):
    """The inflation factor at time t"""

    if t < 0:
        raise ValueError
    else:
        return (1 + INFL_RATE())**(t/12)


def INFL_RATE():
    """Inflation rate"""

    return Input.infl_rate["Inflation"]


def LAPSE_RATE(t):
    """Lapse rate"""

    n = Input.lapse_table.index.max()
    dur_m = list(Input.np.minimum((DUR_M(t)/12).apply(Input.math.ceil), n))
    lapse_rates = Input.lapse_table["Projection"][dur_m]

    return Input.pd.Series(list(lapse_rates), index = MP().index)


def MP():
    """The selected model point as a Series"""

    if type(Input.point_id) == int:
        if Input.point_id == 0:
            return Input.model_point_table
        else:
            return Input.model_point_table.loc[[Input.point_id]]
    elif type(Input.point_id) == list:
        return Input.model_point_table.loc[Input.point_id]
    else:
        print(f"Incompatible data type for Input.point_id: {type(Input.point_id)}")
        raise ValueError


def MORT_RATE_ANN(t):
    """Mortality rate to be applied at time t"""

    fac = Input.mort_scale["Rate"]
    return fac * BASE_MORT_RATE(t)


def MORT_RATE_MLY(t):
    """Monthly mortality rate to be applied at time t"""

    return 1 - (1 - MORT_RATE_ANN(t))**(1/12)


def NET_CF(t):
    """Net cashflow"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return (PREM_PAYBL_M(t)
            + INT_NET_CF(t)
            - DTH_BEN(t)
            - EXPS(t)
            - COMM(t)
            - SURR_BEN(t)
            - MAT_BEN(t)
            - INCM_BEN(t))


def POL_TERM_Y():
    """The policy term of the selected model point.

    The element labeled ``policy_term`` of the Series returned by
    :func:`model_point`."""

    return MP()["policy_term"]


def POLS_DTH(t):
    """Number of death occurring at time t"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return (DUR_M(t) <= POL_TERM_M()) * POLS_IF(t - 1) * MORT_RATE_MLY(t)


def POLS_IF(t):
    """Number of policies in-force

    Currently the model is for new business so the
    initial value is read from :func:`pols_if_init`.
    Subsequent values are defined recursively."""

    if t == 0:
        return INIT_POLS_IF()
    elif t < 0:
        raise ValueError("t cannot be less than 0.")
    else:
        return (DUR_M(t) <= POL_TERM_M()) * (POLS_IF(t-1) - POLS_DTH(t) - POLS_LAPSE(t))


def INIT_POLS_IF(): 
    """Initial Number of Policies In-force

    Number of in-force policies at time 0 referenced from :func:`pols_if`.
    Defaults to 1."""

    return MP()["policy_count"]


def POLS_LAPSE(t):
    """Number of lapse occurring at time t"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return (DUR_M(t) <= POL_TERM_M()) * (POLS_IF(t - 1) - POLS_DTH(t)) * (1-(1 - LAPSE_RATE(t))**(1/12))


def POLS_MAT(t):
    """Number of maturing policies

    The policy maturity occurs at ``t == 12 * policy_term()``,
    after death and lapse during the last period::

        pols_if(t-1) - pols_lapse(t-1) - pols_death(t-1)

    otherwise ``0``."""

    return (DUR_M(t) == POL_TERM_M()) * POLS_IF(t)


def PREM_PP():
    """Annual premium per policy"""

    return MP()["ann_prem"]


def PREM_PAYBL_M(t):
    """Monthly premium income

       Premium income during the period from ``t`` to ``t+1`` defined as::

       premium_pp(t)/premium frequency * pols_if(t)"""

    if t < 0:
        raise ValueError("t cannot be less than 0.")
    elif t == 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return (DUR_M(t) <= PREM_TERM_M()) * PREM_PP()/12 * POLS_IF(t-1)


def PROJ_LEN():
    """Projection length in months

    Projection length in months defined as::

        12 * policy_term() + 1 """

    return POL_TERM_M() - DUR_M(0) + 2


def RESULT_CF():
    """Result table of cashflows"""

    t_len = range(PROJ_LEN().max())

    data = {
        "Premiums": [sum(PREM_PAYBL_M(t)) for t in t_len],
        "Claims": [sum(DTH_BEN(t)) for t in t_len],
        "Expenses": [sum(EXPS(t)) for t in t_len],
        "Commissions": [sum(COMM(t)) for t in t_len],
        "Int_Net_CF": [sum(INT_NET_CF(t)) for t in t_len],        
        "Net Cashflow": [sum(NET_CF(t)) for t in t_len]
    }

    dataframe = Input.pd.DataFrame.from_dict(data)

    return dataframe


def SEX(): 
    """The sex of the selected model point(s)"""

    return MP()["sex"]


def SUM_ASSURED():
    """The sum assured of the selected model point(s)"""

    return MP()["sum_assured"]


def TERMINAL_BEN():
    """Terminal benefit"""

    prem = PREM_PP()
    mat_fac = Input.pd.Series([Input.mat_fac[POL_TERM_Y()[i]] for i in MP().index], index = MP().index)
    return mat_fac * PREM_PP()


def SURR_BEN(t):
    """Surrender benefit"""

    return SURR_VAL(t) * POLS_LAPSE(t)


def MAT_BEN(t):
    """Maturity benefit"""

    return TERMINAL_BEN() * POLS_MAT(t)


def INT_NET_CF(t):
    """Interest earned on net cashflows"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        y = Input.math.ceil(t/12)
        i = (1 + Input.yield_curve["Interest Rates"][y]) ** (1/12) - 1

        return ( i * (PREM_PAYBL_M(t)
                      - EXPS_ACQ(t)
                      - EXPS_MAINT(t)
                      - COMM(t)
                      - INCM_BEN(t)) ) * (DUR_M(t) <= POL_TERM_M())


def EXPS_CLAIM(t):
    """Expenses incured at death/surrender/maturity"""

    return (DUR_M(t) <= POL_TERM_M()) * Input.exp_claim["Claims"] * INFL_FAC(t) * (POLS_DTH(t) + POLS_LAPSE(t) * (SURR_BEN(t) > 0) + POLS_MAT(t))


def PV_DB(t):
    """Present value of death benefit
    for the calculation of surrender value"""

    if t <= 0 or t > PROJ_LEN().max():
        return Input.pd.Series(0, index = MP().index)

    else:
        disc_fac = 1 + Input.yield_curve["Interest Rates"][Input.np.ceil(t/12)]
        mort1 = MORT_RATE_ANN(t-1)
        db = SUM_ASSURED()/PREM_PP()

        val = db * mort1 / (disc_fac ** 0.5) + PV_DB(t+12) * (1 - mort1)/disc_fac

        return (DUR_M(t) <= POL_TERM_M()) * val


def SSV(t):
    """Special surrender values"""

    y = (DUR_M(t)/12).apply(Input.math.ceil)

    ratio = Input.np.minimum(1, y/PREM_TERM_Y())
    return (PV_DB(t) + PV_INCM_BEN(t)) * ratio * PREM_PP()


def BASE_MORT_RATE(t):
    """Base mortality rates at time t"""

    ages = list(AGE(t)); sex = list(Input.mort_table.columns)
    mort_rates = 0

    for i in sex:
        mort_rates += (SEX() == i) * list(Input.mort_table[i][ages])

    return Input.pd.Series(mort_rates, name = Input.inspect.stack()[0][3])


def POL_TERM_M():
    """The policy term of the selected model point."""

    return POL_TERM_Y() * 12


def RESERVE_PP(t):
    """Reserve per policy:
        best estimate liability

    Reserve per policy at ``t`` is defined as:
        max (Reserves.reserve_pp(t), 0)"""

    return (Res.RESERVE_PP(t) > 0) * Res.RESERVE_PP(t)


def RESERVE_IF(t):
    """Reserve in-force:
        best estimate liability

    Reserve in-force at ``t`` is defined as:
        Max(reserve_pp(t), surr_val(t)) * pols_if(t)"""

    return POLS_IF(t) * Input.np.maximum(RESERVE_PP(t), SURR_VAL(t+1))


def INCR_RESERVE(t):
    """Increase in reserves

    Increase in reserves at ``t`` is defined as:
        reserve_if(t) - reserve_if(t-1)
    """

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return RESERVE_IF(t) - RESERVE_IF(t-1)


def INT_RESERVES(t):
    """Interest earned on reserves"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)

    else:
        i = (1 + Input.yield_curve["Interest Rates"][Input.math.ceil(t/12)]) ** (1/12) - 1

        return (DUR_M(t) <= POL_TERM_M()) * RESERVE_IF(t-1) * i


def PROFIT_AFT_TAX(t):
    """Profit after tax

    Profit after tax at ``t`` is defined as:

        profit_bef_tax(t) - tax_profit(t)"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return PROFIT_BEF_TAX(t) - TAX_PROFIT(t)


def SOLVM_IF(t):
    """Solvency margin in-force

    Solvency margin in-force at 't' is defined as:

        pols_if * SM_Ratio * (
            reserve_pp(t) * SM_Res
            + (Dth_Ben - reserve_pp(t) * SM_SAR))"""

    if (t < 0) or (t > PROJ_LEN().max()):
        return Input.pd.Series(0, index = MP().index)

    else:
        ResPP = Res.RESERVE_PP(t) * Input.SM_Rates["% of Reserves"]
        SAR = (DUR_M(t) <= PREM_TERM_M()) * (SUM_ASSURED() - Res.RESERVE_PP(t)) * Input.SM_Rates["% of SAR"]
        SM = (ResPP + SAR) * Input.SM_Rates["Minimum Solvency Ratio"]

        return (DUR_M(t) > 0) * (DUR_M(t) <= POL_TERM_M()) * SM * POLS_IF(t)


def INCR_SOLVM(t):
    """Increase in solvency margin

    Increase in solvency margin at 't' is defined as:

        solvm_if(t) - solvm_if(t - 1)"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return (DUR_M(t) <= POL_TERM_M()) * (SOLVM_IF(t) - SOLVM_IF(t - 1))


def INT_SOLVM(t):
    """Interest earned on solvency margin

    Interest earned at ``t`` is defined as:
        solvm_if(t-1) * disc_rate_mth"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        i = (1 + Input.yield_curve["Interest Rates"][Input.math.ceil(t/12)]) ** (1/12) - 1

        return (DUR_M(t) <= POL_TERM_M()) * SOLVM_IF(t-1) * i


def DISC_RATE_M(t):
    """Monthly discount rate:
        best estimate basis"""

    return (1 + Input.yield_curve["Discount Rates"][Input.math.ceil((t+1)/12)])**(1/12) - 1


def INV_EXP_SOLVM(t):
    """Investment expense on solvency margin"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        y = Input.math.ceil(t/12)        
        fac = (1 + Input.yield_curve["Interest Rates"][y] - Input.exp_maint["% of Reserve"]) ** (1/12) - 1
        return (DUR_M(t) <= POL_TERM_M()) * (INT_SOLVM(t) - SOLVM_IF(t-1) * fac)


def TAX_INT_SOLVM(t):
    """Tax payable on interest earned on
    solvency margin

    This is defined as:
        max(Int_SolvM(t) - Inv_Exp_SolvM, 0) * ShareHolder_Tax"""

    return (DUR_M(t) <= POL_TERM_M()) * Input.np.maximum(INT_SOLVM(t) - INV_EXP_SOLVM(t), 0) * Input.Tax_Rates["Shareholder"]


def PROFIT_AFT_TAX_SOLVM(t):
    """Profit after tax AND solvency margin"""

    return (DUR_M(t) <= POL_TERM_M()) * (PROFIT_AFT_TAX(t)
                                         - INCR_SOLVM(t)
                                         + INT_SOLVM(t)
                                         - INV_EXP_SOLVM(t)
                                         - TAX_INT_SOLVM(t))


def PV_FP(t):
    """Present value of future profits"""

    if t < 0 or t > PROJ_LEN().max():
        return Input.pd.Series(0, index = MP().index)
    else:
        disc_fac = 1 + DISC_RATE_M(t)
        return (DUR_M(t) < POL_TERM_M()) * (PROFIT_AFT_TAX(t+1) + PV_FP(t+1))/disc_fac


def VIF(t):
    """Value in force"""

    if t < 0 or t > PROJ_LEN().max():
        return Input.pd.Series(0, index = MP().index)
    else:
        disc_fac = 1 + DISC_RATE_M(t)
        return (SOLVM_IF(t+1) + PROFIT_AFT_TAX_SOLVM(t+1) + VIF(t+1))/disc_fac - SOLVM_IF(t)


def PREM_TERM_M():
    """Premium paying term in months"""

    return 12 * PREM_TERM_Y()


def GSV(t):
    "Guaranteed Surrender Value"

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)

    else:
        n = Input.GSV_Factor.index.max()
        y = Input.np.minimum((DUR_M(t)/12).apply(Input.math.ceil), n)
        GSVFac = ((PREM_TERM_Y() == 6) * list(Input.GSV_Factor["6-PPT"][y])
              + (PREM_TERM_Y() == 12) * list(Input.GSV_Factor["12-PPT"][y]))

    return y * GSVFac * PREM_PP()


def SURR_VAL(t):
    """Surrender value
        defined as: Max(SSV, GSV)"""

    return Input.np.maximum(SSV(t), GSV(t)) * (DUR_M(t) >= SURR_TERM())


def INCM_FAC(t):
    """Income factor: as a percentage of premium.
    Used for calculation of PV_DB, PV_INCM_BEN
    Applicable for duration `PREM_TERM < y < POL_TERM`"""

    if t > PROJ_LEN().max() or t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        ppt= list(Input.model_point_table.prem_paying_term.unique())
        First5Years = 0; Last5Years = 0

        ages = list(AGE_AT_ENTRY())

        flag = (DUR_M(t) > PREM_TERM_M()) * (DUR_M(t) <= POL_TERM_M())

        for i in ppt:
            First5Years += (PREM_TERM_Y() == i) * list(Input.IncomeBenefit[i]["First 5 years"][ages])
            Last5Years += (PREM_TERM_Y() == i) * list(Input.IncomeBenefit[i]["Last 5 years"][ages])

        rates = ((DUR_M(t) <= POL_TERM_M() - 12 * 5) * First5Years
                 + (DUR_M(t) > POL_TERM_M() - 12 * 5) * Last5Years)

    return flag * rates


def PREM_TERM_Y():
    """Premium paying term in years"""

    return MP()["prem_paying_term"]


def PV_INCM_BEN(t):
    """Present Value of Income Benefit
    for the calculation of surrender value"""

    if t <= 0 or t > PROJ_LEN().max():
        return Input.pd.Series(0, index = MP().index)

    else:
        disc_fac = 1 + Input.yield_curve["Interest Rates"][Input.np.ceil(t/12)]
        mort1 = MORT_RATE_ANN(t-1)

        pv_ib = PV_INCM_BEN(t+12)/disc_fac + INCM_FAC(t)/(disc_fac ** 0.5)

    return (DUR_M(t) <= POL_TERM_M()) * pv_ib * (1 - mort1)


def INCM_BEN(t):
    """Expected income benefit:
        best estimate"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return INCM_FAC(t) * PREM_PP()/12 * POLS_IF(t-1)


def DUR_M(t):
    """Duration in force in months"""

    if t < 0:
        raise ValueError("t cannot be less than 0.")
    elif t == 0:
        return MP()['dur_elapsed']
    else:
        return DUR_M(t-1) + 1


def PROFIT_BEF_TAX(t):
    """Profit before tax

    Profit before tax at ``t`` is defined as:

        (net_cf(t) - incr_reserve(t) + int_reserves(t)) * (1 - tax_rate)"""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return (DUR_M(t) <= POL_TERM_M() + 1) * (NET_CF(t) - INCR_RESERVE(t) + INT_RESERVES(t))


def TAX_PROFIT(t):
    """Tax payable on the profit

    If the profit is negative, then tax is set to 0."""

    if t <= 0:
        return Input.pd.Series(0, index = MP().index)
    else:
        return Input.np.maximum(PROFIT_BEF_TAX(t), 0) * Input.Tax_Rates["Shareholder"]


def SURR_TERM():
    """Term in months till which the surrender value is 0"""

    return PREM_TERM_Y()/6 * 12


def COHORT():

    """The cohort of the model points"""

    return MP()["policy_term"]


# ---------------------------------------------------------------------------
# References

Input = ("Interface", ("..", "Input"), "auto")

Res = ("Interface", ("..", "Reserves"), "auto")